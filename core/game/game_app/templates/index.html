<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pong Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #121212;
            color: white;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }
        
        canvas {
            border: 2px solid white;
            background-color: #000;
            margin-bottom: 10px;
            outline: none; /* Remove default focus outline */
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        
        canvas:focus {
            border-color: #4CAF50; /* Green border when focused */
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.7); /* Glow effect */
        }
        
        .score-board {
            display: flex;
            justify-content: center;
            width: 100%;
            margin-bottom: 10px;
            font-size: 24px;
        }
        
        .score {
            margin: 0 20px;
            padding: 5px 15px;
            background-color: #333;
            border-radius: 5px;
        }
        
        .controls {
            margin-bottom: 15px;
        }
        
        .status {
            margin-bottom: 15px;
            font-size: 18px;
            color: #ccc;
        }
        
        .chat-container {
            width: 100%;
            max-width: 600px;
            margin-top: 20px;
        }
        
        .chat-messages {
            height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background-color: #1e1e1e;
            border-radius: 5px;
        }
        
        .chat-input {
            display: flex;
            width: 100%;
        }
        
        #chat-message {
            flex-grow: 1;
            padding: 8px;
            margin-right: 5px;
            background-color: #333;
            color: white;
            border: none;
            border-radius: 3px;
        }
        
        button {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #3e8e41;
        }
        
        .game-controls {
            margin: 10px 0;
        }
        
        #pauseButton {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            min-width: 200px;
            transition: all 0.3s ease;
        }
        
        #pauseButton:disabled {
            background-color: #cccccc !important;
            cursor: not-allowed !important;
            opacity: 0.7;
            color: #888888;
            box-shadow: none;
        }
        
        #pauseButton.paused {
            background-color: #f44336;
        }
        
        #pauseButton:hover:not(:disabled) {
            opacity: 0.9;
            transform: scale(1.02);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .game-settings {
            margin-top: 10px;
            margin-bottom: 15px;
            background-color: #1e1e1e;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        
        #paddleSpeedSlider {
            margin-top: 5px;
            margin-bottom: 10px;
        }
        
        .toggle-container {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }
        
        .toggle-button {
            padding: 5px 15px;
            border-radius: 15px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .toggle-button.enabled {
            background-color: #4CAF50;
        }
        
        .toggle-button.disabled {
            background-color: #f44336;
        }
    </style>
</head>
<body>
    <h1>Pong Game</h1>
    
    <div class="game-container">
        <div class="score-board">
            <div class="score" id="player1-score">Player 1: 0</div>
            <button id="pauseButton" disabled>Pause Game</button>
            <div class="score" id="player2-score">Player 2: 0</div>
        </div>
        
        <canvas id="game-canvas" width="600" height="400"></canvas>
        
        <div class="status" id="game-status">Waiting for opponent...</div>
        
        <div class="controls">
            <p>Move your paddle: 'W' key to move up, 'S' key to move down</p>
        </div>
    </div>
    
    <div class="chat-container">
        <h3>Chat</h3>
        <div class="chat-messages" id="chat-box"></div>
        <div class="chat-input">
            <input type="text" id="chat-message" placeholder="Type your message...">
            <button onclick="sendChatMessage()">Send</button>
        </div>
    </div>

    <script>
        // Get canvas and context
        const canvas = document.getElementById("game-canvas");
        const ctx = canvas.getContext("2d");
        
        // Make canvas focusable and give it focus
        canvas.tabIndex = 1;
        canvas.focus();
        
        // Game state
        let gameState = {
            ball_x: 50,
            ball_y: 50,
            ball_dx: 3.0,  // Match server's initial speed
            ball_dy: 3.0,  // Match server's initial speed
            player1_position: 50,
            player2_position: 50,
            player1_score: 0,
            player2_score: 0,
            is_full: false
        };
        
        // Client info
        let clientId = null;
        let isPlayer1 = false;
        let isPlayer2 = false;
        
        // Update the constants for better performance
        const PADDLE_HEIGHT = 15;
        const PADDLE_WIDTH = 2;
        const BALL_SIZE = 2;
        const PADDLE_SPEED = 8;
        const MOVEMENT_SMOOTHING = 0.7; // Increased for more responsive movement
        const RENDER_INTERVAL = 1000 / 60; // Target 60 FPS
        
        // Auto paddle movement configuration
        let AUTO_PADDLE_SPEED = 0.5; // Speed of automatic paddle movement (percentage per frame)
        let paddle1Direction = 1; // 1 for down, -1 for up
        let paddle2Direction = -1; // Start in opposite direction
        let autoMovementEnabled = true; // Can be toggled via settings if desired
        let animationId = null; // Store the animation frame ID
        
        // Get room name from URL or generate one
        const urlParams = new URLSearchParams(window.location.search);
        const roomName = urlParams.get('room') || Math.random().toString(36).substring(2, 8);
        
        // Update URL if needed
        if (!urlParams.has('room')) {
            window.history.replaceState({}, '', `?room=${roomName}`);
        }
        
        // Create WebSocket connection
        const socket = new WebSocket(`ws://${window.location.host}/ws/game/${roomName}/`);
        
        socket.onopen = function() {
            console.log("Connected to WebSocket");
            document.getElementById("game-status").innerText = "Connecting to game...";
        };
        
        // Add pause state variables
        let isPaused = false;
        let isGameStarted = false;
        const pauseButton = document.getElementById('pauseButton');
        let pausedByClientId = null;
        let pauseTimer = null;
        const PAUSE_TIMEOUT = 30; // 30 seconds
        let remainingPauseTime = PAUSE_TIMEOUT;
        
        // Remove any existing click handlers and add this new one
        pauseButton.onclick = null;
        pauseButton.addEventListener('click', function(e) {
            console.log('Pause button clicked', { isPaused, pausedByClientId, clientId, isPlayer1, isPlayer2 });
            
            // If the game is not paused, anyone can pause
            if (!isPaused) {
                togglePause();
                return;
            }
            
            // If the game is paused...
            
            // If the player is on the right side (Player 2), prevent resume action
            if (isPlayer2) {
                console.log("Right side player cannot resume the game!");
                e.preventDefault();
                return false;
            }
            
            // If client is not the one who paused, prevent resume
            if (clientId !== pausedByClientId) {
                console.log("Cannot resume - only the player who paused can resume!");
                e.preventDefault();
                return false;
            }
            
            // If we got here, the player is allowed to resume
            togglePause();
        });
        
        // Enhanced WebSocket sending function with logging
        function sendWsMessage(message) {
            console.log("Sending WebSocket message:", message);
            socket.send(JSON.stringify(message));
        }
        
        // Add these variables at the top with other game state variables
        let lastTime = 0;
        let animationFrameId = null;
        
        // Add these variables for optimized rendering
        let lastRenderTime = 0;
        let accumulatedTime = 0;
        let isRendering = false;
        
        // Update the drawGame function for better performance
        function drawGame(currentTime) {
            // Calculate delta time
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Skip frame if too much time has passed
            if (deltaTime > 100) {
                lastRenderTime = currentTime;
                requestNextFrame();
                return;
            }

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Pre-calculate all dimensions once
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const paddleWidth = (PADDLE_WIDTH / 100) * canvasWidth;
            const paddleHeight = (PADDLE_HEIGHT / 100) * canvasHeight;
            const ballSize = (BALL_SIZE / 100) * Math.min(canvasWidth, canvasHeight);
            
            // Pre-calculate positions
            const ballX = (gameState.ball_x / 100) * canvasWidth;
            const ballY = (gameState.ball_y / 100) * canvasHeight;
            const p1Y = (gameState.player1_position / 100) * canvasHeight;
            const p2Y = (gameState.player2_position / 100) * canvasHeight;
            
            // Draw paddles with optimized rendering
            ctx.fillStyle = "white";
            
            // Draw paddles in a single batch
            ctx.fillRect(0, p1Y - paddleHeight/2, paddleWidth, paddleHeight);
            ctx.fillRect(canvasWidth - paddleWidth, p2Y - paddleHeight/2, paddleWidth, paddleHeight);
            
            // Optimize ball trail effect
            const currentSpeed = Math.sqrt(gameState.ball_dx * gameState.ball_dx + gameState.ball_dy * gameState.ball_dy);
            if (currentSpeed > 3) {
                const trailLength = Math.min(currentSpeed * 1.2, 3); // Reduced trail length
                ctx.globalAlpha = 0.15; // Reduced opacity
                ctx.beginPath();
                ctx.arc(ballX - (gameState.ball_dx * trailLength), ballY - (gameState.ball_dy * trailLength), ballSize * 0.8, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
            
            // Draw main ball
            ctx.beginPath();
            ctx.arc(ballX, ballY, ballSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw center line only when needed
            if (!isPaused) {
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(canvasWidth / 2, 0);
                ctx.lineTo(canvasWidth / 2, canvasHeight);
                ctx.strokeStyle = "white";
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            requestNextFrame();
        }
        
        // Add this new function for optimized frame requesting
        function requestNextFrame() {
            if (!isPaused && isGameStarted) {
                animationFrameId = requestAnimationFrame(drawGame);
            }
        }
        
        // Update the updateGameState function for smoother movement
        function updateGameState(state) {
            // Keep track of previous positions for smooth animations
            const prevPlayer1Position = gameState.player1_position;
            const prevPlayer2Position = gameState.player2_position;
            
            // Update game state
            gameState = state;
            
            // Improved paddle movement smoothing with faster response
            if (isPlayer1) {
                const targetPosition = state.player1_position;
                const currentPosition = prevPlayer1Position;
                const diff = targetPosition - currentPosition;
                gameState.player1_position = currentPosition + (diff * MOVEMENT_SMOOTHING);
            }
            
            if (isPlayer2) {
                const targetPosition = state.player2_position;
                const currentPosition = prevPlayer2Position;
                const diff = targetPosition - currentPosition;
                gameState.player2_position = currentPosition + (diff * MOVEMENT_SMOOTHING);
            }
            
            // Determine if we're player1 or player2
            if (!isPlayer1 && !isPlayer2) {
                if (clientId && state.player1_id === clientId) {
                    console.log("I am Player 1");
                    isPlayer1 = true;
                    isPlayer2 = false;
                } else if (clientId && state.player2_id === clientId) {
                    console.log("I am Player 2");
                    isPlayer1 = false;
                    isPlayer2 = true;
                }
            }
            
            // Update status
            if (!state.is_full) {
                document.getElementById("game-status").innerText = "Waiting for opponent...";
                pauseButton.disabled = true;
            } else if (state.winner_id) {
                // This will be handled by the game_over event
                pauseButton.disabled = true;
            } else {
                if (!isPaused) {
                    document.getElementById("game-status").innerText = "Game in progress";
                }
                pauseButton.disabled = false;
            }
            
            // Update score
            document.getElementById("player1-score").innerText = `Player 1: ${state.player1_score}`;
            document.getElementById("player2-score").innerText = `Player 2: ${state.player2_score}`;
            
            // Start animation if not already running
            if (!animationFrameId && !isPaused && isGameStarted) {
                animationFrameId = requestAnimationFrame(drawGame);
            }
        }
        
        socket.onmessage = function(event) {
            const data = JSON.parse(event.data);
            console.log("Received 11:", data);
            
            // Handle different message types
            switch(data.type) {
                case "game_state":
                    if (data.client_id) {
                        clientId = data.client_id;
                    }
                    console.log("Updating game state net:", data.state.player1_position, data.state.player2_position);
                    updateGameState(data.state);
                    // Enable pause button when game starts
                    if (!isGameStarted && data.state.is_full) {
                        isGameStarted = true;
                        pauseButton.disabled = false;
                    } 
                    break;

                case 'player_joined':
                    handlePlayerJoined(data);
                    break;
                    
                case 'chat':
                    handleChatMessage(data);
                    break;
                    
                case 'game_over':
                    handleGameOver(data);
                    break;
                    
                case 'game_paused':
                    console.log('Received pause state', data);
                    isPaused = data.paused;
                    pausedByClientId = data.pausedByClientId;
                    remainingPauseTime = data.remainingTime;

                    if (isPaused && clientId !== pausedByClientId) {
                        startPauseTimer();
                    } else if (!isPaused) {
                        clearPauseTimer();
                    }

                    updatePauseButtonState();
                    updateGameStatus();
                    break;
                default:
                    console.log('Default...')
                    // Set client ID if available
                    if (data.client_id && !clientId) {
                        clientId = data.client_id;
                        console.log("My client ID:", clientId);
                    }
            }
        };
        
        socket.onclose = function() {
            console.log("Disconnected from WebSocket");
            document.getElementById("game-status").innerText = "Connection lost. Please refresh.";
        };
        
        // Add focus event for the canvas to make sure keyboard events work
        canvas.addEventListener('click', function() {
            console.log("Canvas clicked, setting focus");
            this.focus();
        });
        
        window.addEventListener('focus', function() {
            console.log("Window focused");
            canvas.focus();
        });
        
        document.addEventListener('click', function() {
            console.log("Document clicked");
            if (document.activeElement !== canvas) {
                console.log("Canvas not focused, setting focus");
                canvas.focus();
            }
        });
        
        // Update the keyboard controls for more responsive movement
        document.addEventListener('keydown', function(e) {
            if (isPaused || (!isPlayer1 && !isPlayer2)) {
                return;
            }
            
            let newPosition = isPlayer1 ? gameState.player1_position : gameState.player2_position;
            
            if (e.key.toLowerCase() === 'w') {
                newPosition = Math.max(newPosition - PADDLE_SPEED, PADDLE_HEIGHT/2);
            } else if (e.key.toLowerCase() === 's') {
                newPosition = Math.min(newPosition + PADDLE_SPEED, 100 - PADDLE_HEIGHT/2);
            } else {
                return;
            }
            
            // Update local position immediately for responsiveness
            if (isPlayer1) {
                gameState.player1_position = newPosition;
            } else if (isPlayer2) {
                gameState.player2_position = newPosition;
            }
            
            // Send paddle position to server
            sendWsMessage({
                type: 'paddle_move',
                position: newPosition
            });
            
            // Force immediate redraw
            if (!isRendering) {
                isRendering = true;
                drawGame(performance.now());
                isRendering = false;
            }
        });
        
        // Function to handle a player joining
        function handlePlayerJoined(data) {
            console.log("Player joined:", data.client_id);
            // Update game state
            if (data.state) {
                updateGameState(data.state);
            }
            
            // Add chat message
            const isMe = data.client_id === clientId;
            const chatBox = document.getElementById("chat-box");
            chatBox.innerHTML += `<p><strong>${isMe ? 'You' : 'Opponent'}</strong> joined the game</p>`;
            chatBox.scrollTop = chatBox.scrollHeight;
        }
        
        // Function to handle chat messages
        function handleChatMessage(data) {
            const isMe = data.client_id === clientId;
            const chatBox = document.getElementById("chat-box");
            chatBox.innerHTML += `<p><strong>${isMe ? 'You' : 'Opponent'}</strong>: ${data.message}</p>`;
            chatBox.scrollTop = chatBox.scrollHeight;
        }
        
        // Function to handle game over
        function handleGameOver(data) {
            const winnerId = data.winner_id;
            let message = "";
            
            // Check if we're the winner
            if (isPlayer1 && winnerId === gameState.player1_id || 
                isPlayer2 && winnerId === gameState.player2_id) {
                message = "You win!";
            } else {
                message = "You lose!";
            }
            
            // For spectators or if winner logic fails
            if (!isPlayer1 && !isPlayer2) {
                if (winnerId === gameState.player1_id) {
                    message = "Player 1 wins!";
                } else {
                    message = "Player 2 wins!";
                }
            }
            
            document.getElementById("game-status").innerText = message;
            
            // Add chat message
            const chatBox = document.getElementById("chat-box");
            chatBox.innerHTML += `<p><strong>Game Over</strong>: ${message}</p>`;
            chatBox.scrollTop = chatBox.scrollHeight;
        }
        
        // Function to send chat messages
        function sendChatMessage() {
            const input = document.getElementById("chat-message");
            const message = input.value.trim();
            
            if (message) {
                sendWsMessage({
                    type: 'chat',
                    message: message
                });
                
                input.value = "";
            }
        }
        
        // Allow Enter key to send chat messages
        document.getElementById("chat-message").addEventListener("keydown", function(e) {
            if (e.key === "Enter") {
                sendChatMessage();
            }
        });
        
        function startPauseTimer() {
            remainingPauseTime = PAUSE_TIMEOUT;
            updatePauseButtonState();

            if (pauseTimer) {
                clearInterval(pauseTimer);
            }

            pauseTimer = setInterval(() => {
                remainingPauseTime--;
                updatePauseButtonState();

                if (remainingPauseTime <= 0) {
                    if (clientId === pausedByClientId) {
                        togglePause();
                    }
                }
            }, 1000);
        }

        function clearPauseTimer() {
            if (pauseTimer) {
                clearInterval(pauseTimer);
                pauseTimer = null;
            }
            remainingPauseTime = PAUSE_TIMEOUT;
        }

        function updatePauseButtonState() {
            console.log('Updating button state', { isPaused, pausedByClientId, clientId, isPlayer1, isPlayer2 });
            
            if (!isGameStarted) {
                pauseButton.disabled = true;
                pauseButton.textContent = 'Pause Game';
                pauseButton.style.cursor = 'not-allowed';
                return;
            }

            if (isPaused) {
                // Always disable resume for Player 2 (right side)
                if (isPlayer2) {
                    pauseButton.textContent = `Resuming in ${remainingPauseTime}s`;
                    pauseButton.disabled = true;
                    pauseButton.style.cursor = 'not-allowed';
                    pauseButton.classList.add('paused');
                }
                // Enable for the player who paused (if they're not Player 2)
                else if (clientId === pausedByClientId) {
                    pauseButton.textContent = `Resume Game (${remainingPauseTime}s)`;
                    pauseButton.disabled = false;
                    pauseButton.style.cursor = 'pointer';
                    pauseButton.classList.add('paused');
                } 
                // Disable for the player who didn't pause
                else {
                    pauseButton.textContent = `Resuming in ${remainingPauseTime}s`;
                    pauseButton.disabled = true;
                    pauseButton.style.cursor = 'not-allowed';
                    pauseButton.classList.add('paused');
                }
            } else {
                pauseButton.textContent = 'Pause Game';
                pauseButton.classList.remove('paused');
                pauseButton.disabled = false;
                pauseButton.style.cursor = 'pointer';
            }
        }

        function updateGameStatus() {
            const statusElement = document.getElementById("game-status");
            if (isPaused) {
                if (isPlayer2) {
                    // Clear message for Player 2 that they cannot resume
                    statusElement.innerText = `Game paused. Only your opponent can resume.`;
                } else if (clientId === pausedByClientId) {
                    statusElement.innerText = `You paused the game. Click 'Resume' or wait ${remainingPauseTime}s for auto-resume.`;
                } else {
                    statusElement.innerText = `Game paused by opponent. Resuming in ${remainingPauseTime}s...`;
                }
            } else {
                statusElement.innerText = isGameStarted ? "Game in progress" : "Waiting for opponent...";
            }
        }

        // Add cleanup for animation frame
        function cleanup() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            clearPauseTimer();
        }
        
        // Update the window unload event listener
        window.addEventListener('beforeunload', cleanup);
        
        // Update the pause handling
        function togglePause() {
            console.log('Toggling pause', { isPaused, pausedByClientId, clientId });
            
            // We should not need this check here since it's handled by the click handler
            // but keeping it as an extra safety measure
            if (isPaused && clientId !== pausedByClientId) {
                console.log("Only the client who paused can resume!");
                return;
            }

            if (isPaused && isPlayer2) {
                console.log("Player 2 cannot resume the game!");
                return;
            }

            isPaused = !isPaused;

            if (isPaused) {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                pausedByClientId = clientId;
                startPauseTimer();
            } else {
                pausedByClientId = null;
                clearPauseTimer();
            }

            // Use the enhanced send function
            sendWsMessage({
                type: 'toggle_pause',
                paused: isPaused,
                pausedByClientId: pausedByClientId,
                remainingTime: remainingPauseTime
            });

            updatePauseButtonState();
            updateGameStatus();
        }

        // Start the game loop
        if (isGameStarted && !isPaused) {
            animationFrameId = requestAnimationFrame(drawGame);
        }

        // Add event listener for the paddle speed slider
        document.getElementById('paddleSpeedSlider').addEventListener('input', function(e) {
            AUTO_PADDLE_SPEED = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = AUTO_PADDLE_SPEED.toFixed(1);
            console.log('Paddle speed updated to:', AUTO_PADDLE_SPEED);
        });
        
        // Add event listener for the auto movement toggle button
        document.getElementById('autoMovementToggle').addEventListener('click', function() {
            autoMovementEnabled = !autoMovementEnabled;
            this.textContent = autoMovementEnabled ? 'ON' : 'OFF';
            this.classList.toggle('enabled', autoMovementEnabled);
            this.classList.toggle('disabled', !autoMovementEnabled);
            console.log('Auto movement toggled:', autoMovementEnabled ? 'enabled' : 'disabled');
        });
    </script>
    
</body>
</html> 